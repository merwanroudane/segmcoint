<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Full Example — segmcoint</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;0,8..60,700;1,8..60,400&family=JetBrains+Mono:wght@400;500&family=Source+Sans+3:wght@300;400;500;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<style>
:root {
  --bg: #FAFAF8;
  --bg-card: #FFFFFF;
  --bg-code: #F8F6F2;
  --bg-output: #F3F1EC;
  --bg-nav: #FFFFFF;
  --text: #2D2A24;
  --text-light: #6B6560;
  --text-muted: #9A938B;
  --accent: #C45527;
  --accent-light: #E8DDD4;
  --border: #E8E4DE;
  --border-light: #F0ECE6;
  --teal: #1A7A6D;
  --teal-bg: #E8F5F2;
  --blue: #2E6CA4;
  --green: #3A7D44;
  --shadow: 0 1px 3px rgba(45,42,36,0.06);
  --shadow-lg: 0 4px 20px rgba(45,42,36,0.08);
  --radius: 8px;
  --code-kw: #8250DF;
  --code-str: #0A6640;
  --code-fn: #C45527;
  --code-cm: #9A938B;
  --code-num: #2E6CA4;
}
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
html{scroll-behavior:smooth;font-size:16px}
body{font-family:'Source Sans 3',sans-serif;color:var(--text);background:var(--bg);line-height:1.7;-webkit-font-smoothing:antialiased}

/* TOP BAR */
.top-bar{position:fixed;top:0;left:0;right:0;z-index:100;background:var(--bg-nav);border-bottom:1px solid var(--border);height:56px;display:flex;align-items:center;padding:0 2rem;backdrop-filter:blur(12px)}
.top-bar .logo{font-family:'Source Serif 4',serif;font-weight:700;font-size:1.25rem;color:var(--accent);text-decoration:none;letter-spacing:-.02em}
.top-bar .logo span{color:var(--text-muted);font-weight:400;font-size:.85rem;margin-left:.5rem}
.top-bar nav{margin-left:auto;display:flex;gap:.25rem}
.top-bar nav a{font-size:.82rem;font-weight:500;color:var(--text-light);text-decoration:none;padding:.35rem .75rem;border-radius:6px;transition:all .15s}
.top-bar nav a:hover{background:var(--accent-light);color:var(--accent)}

/* LAYOUT */
.page{max-width:960px;margin:76px auto 4rem;padding:0 2rem}

/* HERO */
.hero{padding:1.5rem 0 1.5rem;margin-bottom:1.5rem;border-bottom:2px solid var(--border)}
.hero h1{font-family:'Source Serif 4',serif;font-size:2rem;font-weight:700;letter-spacing:-.03em;line-height:1.25;margin-bottom:.4rem}
.hero p{font-size:1rem;color:var(--text-light);max-width:700px}
.hero .meta{margin-top:.8rem;font-size:.85rem;color:var(--text-muted)}
.hero .meta strong{color:var(--accent)}

/* DOWNLOAD BAR */
.dl-bar{display:flex;gap:.75rem;flex-wrap:wrap;padding:1rem 1.25rem;background:var(--teal-bg);border:1px solid #C8E6DF;border-radius:var(--radius);margin-bottom:2rem}
.dl-bar a{display:inline-flex;align-items:center;gap:.4rem;font-size:.82rem;font-weight:600;color:var(--teal);text-decoration:none;padding:.4rem .8rem;border:1px solid #A8D5CB;border-radius:6px;background:#fff;transition:all .12s}
.dl-bar a:hover{background:var(--teal);color:#fff;border-color:var(--teal)}
.dl-bar a svg{width:14px;height:14px}
.dl-bar .label{font-size:.75rem;font-weight:600;color:#15685C;letter-spacing:.04em;text-transform:uppercase;align-self:center}

/* NOTEBOOK CELLS */
.nb-cell{margin-bottom:.5rem}
.nb-md{padding:.6rem 0}
.nb-md h1{font-family:'Source Serif 4',serif;font-size:1.8rem;font-weight:700;letter-spacing:-.02em;margin:2rem 0 .6rem;padding-bottom:.4rem;border-bottom:2px solid var(--border);color:var(--text)}
.nb-md h2{font-family:'Source Serif 4',serif;font-size:1.45rem;font-weight:600;margin:2.2rem 0 .6rem;padding-bottom:.35rem;border-bottom:1px solid var(--border);color:var(--text)}
.nb-md h3{font-family:'Source Serif 4',serif;font-size:1.15rem;font-weight:600;margin:1.5rem 0 .5rem;color:var(--text)}
.nb-md p{margin:.5rem 0;line-height:1.65}
.nb-md table{width:100%;border-collapse:collapse;font-size:.82rem;margin:.75rem 0}
.nb-md th{background:#F7F5F0;font-weight:600;text-align:left;padding:.45rem .6rem;border:1px solid var(--border);font-size:.78rem}
.nb-md td{padding:.4rem .6rem;border:1px solid var(--border-light)}
.nb-md tr:nth-child(even){background:#FCFBF9}
.nb-md ul,.nb-md ol{margin:.4rem 0 .4rem 1.5rem}
.nb-md li{margin:.15rem 0}
.nb-md em{color:var(--text-light)}
.nb-md strong{color:var(--text)}
.nb-md code{font-family:'JetBrains Mono',monospace;font-size:.84em;background:var(--bg-code);padding:.1em .3em;border-radius:3px}
.nb-md hr{border:none;border-top:1px solid var(--border);margin:1.5rem 0}

/* CODE CELL */
.code-wrap{border:1px solid var(--border);border-radius:var(--radius);overflow:hidden;margin:.4rem 0;box-shadow:var(--shadow)}
.code-header{display:flex;align-items:center;gap:.5rem;padding:.3rem .7rem;background:#F0EDE7;border-bottom:1px solid var(--border);font-size:.7rem;color:var(--text-muted);font-weight:500}
.code-header .lang{background:var(--accent-light);color:var(--accent);padding:.1rem .4rem;border-radius:3px;font-weight:600;font-size:.65rem;letter-spacing:.04em}
.code-header .num{margin-left:auto;font-family:'JetBrains Mono',monospace;font-size:.65rem}
.code-block{background:var(--bg-code);padding:.75rem 1rem;font-family:'JetBrains Mono',monospace;font-size:.74rem;line-height:1.55;overflow-x:auto;white-space:pre;color:var(--text)}
.output-wrap{border-top:1px dashed var(--border);background:var(--bg-output);padding:.7rem 1rem;font-family:'JetBrains Mono',monospace;font-size:.72rem;line-height:1.5;overflow-x:auto;white-space:pre;color:var(--text-light)}
.output-label{font-family:'Source Sans 3',sans-serif;font-size:.65rem;font-weight:600;color:var(--text-muted);text-transform:uppercase;letter-spacing:.06em;margin-bottom:.2rem;display:block}
.output-img{border-top:1px dashed var(--border);background:#FFFFFF;padding:.75rem;text-align:center}
.output-img img{max-width:100%;border-radius:4px}

/* FORMULA BOX */
.formula-box{background:#EBF3FA;border:1px solid #D0DEE9;border-radius:var(--radius);padding:1rem 1.25rem;margin:.75rem 0;text-align:center}

/* FOOTER */
footer{max-width:960px;margin:0 auto;padding:2rem;border-top:1px solid var(--border);font-size:.8rem;color:var(--text-muted);text-align:center}
footer a{color:var(--accent);text-decoration:none}

a{color:var(--accent)}
@media(max-width:700px){.page{padding:0 1rem}.top-bar nav{display:none}}
</style>
</head>
<body>
<header class="top-bar">
  <a href="index.html" class="logo">segmcoint <span>v1.0.0</span></a>
  <nav>
    <a href="index.html">Documentation</a>
    <a href="notebook.html" style="background:var(--accent-light);color:var(--accent)">Full Example</a>
  </nav>
</header>

<div class="page">

<section class="hero">
  <h1>Full Example with Outputs</h1>
  <p>Complete Jupyter notebook — Segmented Cointegration Analysis of Kilian (2009) Oil Market Data — rendered with all code cells and outputs.</p>
  <div class="meta">by <strong>Dr Merwan Roudane</strong> · <a href="mailto:merwanroudane920@gmail.com">merwanroudane920@gmail.com</a></div>
</section>

<div class="dl-bar">
  <span class="label">Downloads :</span>
  <a href="downloads/segmented_cointegration_kilian.ipynb"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg> Notebook (.ipynb)</a>
  <a href="downloads/Copy_of_Killian.xlsx"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4M7 10l5 5 5-5M12 15V3"/></svg> Data (.xlsx)</a>
</div>

<div class="nb-cell nb-md">
<h1>Segmented Cointegration Analysis</h1>
<h2 id="nb-s0">Application to Kilian (2009) Oil Market Data</h2>

<p><strong>Tests implemented:</strong></p>
<li>Kim, J.-Y. (2003). *Inference on Segmented Cointegration*. Econometric Theory, 19, 620–639.</li>
<li>Martins, L.F. &amp; Rodrigues, P.M.M. (2022). *Tests for Segmented Cointegration: An Application to US Government Budgets*. Empirical Economics, 63, 567–600.</li>

<p><strong>Author:</strong> Dr Merwan Roudane</p>
<p><strong>Package:</strong> <code>segmcoint</code> v1.0.0</p>
<p><strong>Date:</strong> February 2026</p>
</div>
<div class="nb-cell nb-md">
<h2 id="nb-s1">0. Environment &amp; Watermark</h2>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [1]</span></div>
<div class="code-block">import sys, platform, datetime

# Watermark — environment information
print(&quot;=&quot; * 65)
print(&quot;  ENVIRONMENT WATERMARK&quot;)
print(&quot;=&quot; * 65)
print(f&quot;  Python          : {platform.python_version()}&quot;)
print(f&quot;  Platform        : {platform.platform()}&quot;)
print(f&quot;  Date            : {datetime.datetime.now().strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)}&quot;)
print()

import numpy as np
import pandas as pd
import scipy
import matplotlib
import matplotlib.pyplot as plt
import seaborn as sns
from tabulate import tabulate

print(f&quot;  NumPy           : {np.__version__}&quot;)
print(f&quot;  Pandas          : {pd.__version__}&quot;)
print(f&quot;  SciPy           : {scipy.__version__}&quot;)
print(f&quot;  Matplotlib      : {matplotlib.__version__}&quot;)
print(f&quot;  Seaborn         : {sns.__version__}&quot;)

# Add segmcoint to path
sys.path.insert(0, &#x27;.&#x27;)  # segmcoint package in same directory
import segmcoint
print(f&quot;  segmcoint       : {segmcoint.__version__}&quot;)
print(f&quot;  tabulate        : installed&quot;)
print(&quot;=&quot; * 65)

# imports from segmcoint
from segmcoint import (
    kim_test, mr_test, kim_break_estimator,
    generate_segmented_data, ols_residuals
)
from segmcoint.kim2003 import get_critical_value
from segmcoint.martins_rodrigues2022 import get_mr_critical_value

# Plotting defaults
plt.rcParams.update({
    &#x27;figure.figsize&#x27;: (14, 5),
    &#x27;figure.dpi&#x27;: 120,
    &#x27;axes.grid&#x27;: True,
    &#x27;grid.alpha&#x27;: 0.3,
    &#x27;font.size&#x27;: 11,
    &#x27;axes.titlesize&#x27;: 13,
    &#x27;axes.labelsize&#x27;: 12,
})
sns.set_style(&quot;whitegrid&quot;)

import warnings
warnings.filterwarnings(&#x27;ignore&#x27;)
print(&quot;\n✓ All packages loaded successfully.&quot;)</div>
<div class="output-wrap"><span class="output-label">Output</span>=================================================================
  ENVIRONMENT WATERMARK
=================================================================
  Python          : 3.13.7
  Platform        : Windows-11-10.0.26100-SP0
  Date            : 2026-02-06 12:56:47

  NumPy           : 2.3.4
  Pandas          : 2.3.3
  SciPy           : 1.16.3
  Matplotlib      : 3.10.7
  Seaborn         : 0.13.2
  segmcoint       : 1.0.0
  tabulate        : installed
=================================================================

✓ All packages loaded successfully.
</div>
</div>
</div>
<div class="nb-cell nb-md">
<hr>
<h2 id="nb-s4">1. Data Loading &amp; Inspection</h2>

<p>We use the Kilian (2009) oil market dataset consisting of three monthly variables (1973:02 – 2007:12):</p>

<table>
<tr><th>Variable</th><th>Description</th></tr>
<p>|----------|-------------|</p>
<tr><td>`dprod`</td><td>Percentage change in global crude oil production</td></tr>
<tr><td>`rea`</td><td>Index of real economic activity (dry cargo shipping rates)</td></tr>
<tr><td>`rpo`</td><td>Real price of oil (deflated by US CPI)</td></tr>
</table>

<p><strong>Reference:</strong> Kilian, L. (2009). <em>Not All Oil Price Shocks Are Alike: Disentangling Demand and Supply Shocks in the Crude Oil Market</em>. American Economic Review, 99(3), 1053–1069.</p>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [2]</span></div>
<div class="code-block"># ── Load Excel data ──────────────────────────────────────────
import openpyxl

path = r&quot;c:\Users\HP\Downloads\Copy of Killian.xlsx&quot;
wb = openpyxl.load_workbook(path)
ws = wb.active



rows = []
for row in ws.iter_rows(min_row=2, max_row=ws.max_row, values_only=True):
    if row[0] is not None:
        rows.append(row[:4])

df = pd.DataFrame(rows, columns=[&#x27;date&#x27;, &#x27;dprod&#x27;, &#x27;rea&#x27;, &#x27;rpo&#x27;]).astype(float)

# Create proper datetime index
years  = df[&#x27;date&#x27;].astype(int)
months = ((df[&#x27;date&#x27;] - years) * 100 + 0.5).astype(int)
df.index = pd.to_datetime(
    [f&quot;{y}-{m:02d}-01&quot; for y, m in zip(years, months)]
)
df.index.name = &#x27;Date&#x27;

T = len(df)
print(f&quot;Sample : {df.index[0].strftime(&#x27;%Y:%m&#x27;)} – {df.index[-1].strftime(&#x27;%Y:%m&#x27;)}&quot;)
print(f&quot;T      : {T} observations\n&quot;)

# Display first and last rows
print(tabulate(
    df[[&#x27;dprod&#x27;, &#x27;rea&#x27;, &#x27;rpo&#x27;]].head(8),
    headers=&#x27;keys&#x27;, tablefmt=&#x27;fancy_grid&#x27;, floatfmt=&#x27;.4f&#x27;,
    showindex=True
))
print(&quot;\n  ⋮\n&quot;)
print(tabulate(
    df[[&#x27;dprod&#x27;, &#x27;rea&#x27;, &#x27;rpo&#x27;]].tail(5),
    headers=&#x27;keys&#x27;, tablefmt=&#x27;fancy_grid&#x27;, floatfmt=&#x27;.4f&#x27;,
    showindex=True
))</div>
<div class="output-wrap"><span class="output-label">Output</span>Sample : 1973:02 – 2007:12
T      : 419 observations

╒═════════════════════╤══════════╤═════════╤══════════╕
│ Date                │    dprod │     rea │      rpo │
╞═════════════════════╪══════════╪═════════╪══════════╡
│ 1973-02-01 00:00:00 │  11.8773 │ 36.0642 │ -47.9995 │
├─────────────────────┼──────────┼─────────┼──────────┤
│ 1973-03-01 00:00:00 │   1.4191 │ 41.5270 │ -48.2865 │
├─────────────────────┼──────────┼─────────┼──────────┤
│ 1973-04-01 00:00:00 │   1.1777 │ 43.9913 │ -47.0825 │
├─────────────────────┼──────────┼─────────┼──────────┤
│ 1973-05-01 00:00:00 │  27.4551 │ 48.1059 │ -43.8577 │
├─────────────────────┼──────────┼─────────┼──────────┤
│ 1973-06-01 00:00:00 │ -13.1104 │ 52.0335 │ -41.5711 │
├─────────────────────┼──────────┼─────────┼──────────┤
│ 1973-07-01 00:00:00 │  36.2581 │ 52.9429 │ -40.9880 │
├─────────────────────┼──────────┼─────────┼──────────┤
│ 1973-08-01 00:00:00 │ -14.0844 │ 57.6660 │ -42.7817 │
├─────────────────────┼──────────┼─────────┼──────────┤
│ 1973-09-01 00:00:00 │  20.8365 │ 63.1559 │ -37.5739 │
╘═════════════════════╧══════════╧═════════╧══════════╛

  ⋮

╒═════════════════════╤══════════╤═════════╤═════════╕
│ Date                │    dprod │     rea │     rpo │
╞═════════════════════╪══════════╪═════════╪═════════╡
│ 2007-08-01 00:00:00 │ -11.4551 │ 47.0547 │ 60.2149 │
├─────────────────────┼──────────┼─────────┼─────────┤
│ 2007-09-01 00:00:00 │  14.1423 │ 50.8694 │ 65.4597 │
├─────────────────────┼──────────┼─────────┼─────────┤
│ 2007-10-01 00:00:00 │  10.1049 │ 56.8068 │ 73.6764 │
├─────────────────────┼──────────┼─────────┼─────────┤
│ 2007-11-01 00:00:00 │  -3.0388 │ 57.2742 │ 81.2086 │
├─────────────────────┼──────────┼─────────┼─────────┤
│ 2007-12-01 00:00:00 │   7.3159 │ 56.8243 │ 78.1154 │
╘═════════════════════╧══════════╧═════════╧═════════╛
</div>
</div>
</div>
<div class="nb-cell nb-md">
<h2 id="nb-s10">2. Descriptive Statistics</h2>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [3]</span></div>
<div class="code-block"># ── Summary statistics ───────────────────────────────────────
desc = df[[&#x27;dprod&#x27;, &#x27;rea&#x27;, &#x27;rpo&#x27;]].describe().T
desc[&#x27;skew&#x27;]     = df[[&#x27;dprod&#x27;, &#x27;rea&#x27;, &#x27;rpo&#x27;]].skew()
desc[&#x27;kurtosis&#x27;] = df[[&#x27;dprod&#x27;, &#x27;rea&#x27;, &#x27;rpo&#x27;]].kurtosis()

print(tabulate(
    desc[[&#x27;count&#x27;, &#x27;mean&#x27;, &#x27;std&#x27;, &#x27;min&#x27;, &#x27;25%&#x27;, &#x27;50%&#x27;, &#x27;75%&#x27;, &#x27;max&#x27;, &#x27;skew&#x27;, &#x27;kurtosis&#x27;]],
    headers=[&#x27;N&#x27;, &#x27;Mean&#x27;, &#x27;Std&#x27;, &#x27;Min&#x27;, &#x27;Q1&#x27;, &#x27;Median&#x27;, &#x27;Q3&#x27;, &#x27;Max&#x27;, &#x27;Skew&#x27;, &#x27;Kurt&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, floatfmt=&#x27;.4f&#x27;, showindex=True
))

print(&quot;\n── Correlation Matrix ─────────────────────────────────────&quot;)
corr = df[[&#x27;dprod&#x27;, &#x27;rea&#x27;, &#x27;rpo&#x27;]].corr()
print(tabulate(corr, headers=&#x27;keys&#x27;, tablefmt=&#x27;fancy_grid&#x27;, floatfmt=&#x27;.4f&#x27;, showindex=True))</div>
<div class="output-wrap"><span class="output-label">Output</span>╒═══════╤══════════╤════════╤═════════╤═══════════╤══════════╤══════════╤═════════╤═════════╤═════════╤═════════╕
│       │        N │   Mean │     Std │       Min │       Q1 │   Median │      Q3 │     Max │    Skew │    Kurt │
╞═══════╪══════════╪════════╪═════════╪═══════════╪══════════╪══════════╪═════════╪═════════╪═════════╪═════════╡
│ dprod │ 419.0000 │ 0.8896 │ 20.5229 │ -118.8875 │  -6.7368 │   2.4594 │ 10.1038 │ 77.9832 │ -1.5363 │  8.1911 │
├───────┼──────────┼────────┼─────────┼───────────┼──────────┼──────────┼─────────┼─────────┼─────────┼─────────┤
│ rea   │ 419.0000 │ 0.1846 │ 24.1136 │  -47.3887 │ -16.8849 │  -5.8494 │ 12.4695 │ 76.7121 │  0.9113 │  0.3590 │
├───────┼──────────┼────────┼─────────┼───────────┼──────────┼──────────┼─────────┼─────────┼─────────┼─────────┤
│ rpo   │ 419.0000 │ 0.1129 │ 45.6595 │ -114.7795 │ -36.5168 │ -10.4489 │ 36.9397 │ 90.6366 │  0.0656 │ -0.9173 │
╘═══════╧══════════╧════════╧═════════╧═══════════╧══════════╧══════════╧═════════╧═════════╧═════════╧═════════╛

── Correlation Matrix ─────────────────────────────────────
╒═══════╤═════════╤═════════╤═════════╕
│       │   dprod │     rea │     rpo │
╞═══════╪═════════╪═════════╪═════════╡
│ dprod │  1.0000 │ -0.0290 │ -0.0358 │
├───────┼─────────┼─────────┼─────────┤
│ rea   │ -0.0290 │  1.0000 │  0.3693 │
├───────┼─────────┼─────────┼─────────┤
│ rpo   │ -0.0358 │  0.3693 │  1.0000 │
╘═══════╧═════════╧═════════╧═════════╛
</div>
</div>
</div>
<div class="nb-cell nb-md">
<h2 id="nb-s12">3. Time Series Visualization</h2>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [4]</span></div>
<div class="code-block"># ── Individual time series ───────────────────────────────────
fig, axes = plt.subplots(3, 1, figsize=(14, 10), sharex=True)

variables = [&#x27;dprod&#x27;, &#x27;rea&#x27;, &#x27;rpo&#x27;]
titles = [
    &#x27;Global Oil Production Growth (% change)&#x27;,
    &#x27;Real Economic Activity Index&#x27;,
    &#x27;Real Price of Oil&#x27;
]
colors = [&#x27;#2196F3&#x27;, &#x27;#4CAF50&#x27;, &#x27;#FF5722&#x27;]

for ax, var, title, color in zip(axes, variables, titles, colors):
    ax.plot(df.index, df[var], color=color, linewidth=0.9, alpha=0.9)
    ax.fill_between(df.index, 0, df[var], alpha=0.15, color=color)
    ax.axhline(y=0, color=&#x27;black&#x27;, linewidth=0.5, linestyle=&#x27;-&#x27;)
    ax.set_title(title, fontweight=&#x27;bold&#x27;)
    ax.set_ylabel(var)
    # Shade NBER recessions (approximate)
    for start, end in [(&#x27;1973-11&#x27;,&#x27;1975-03&#x27;), (&#x27;1980-01&#x27;,&#x27;1980-07&#x27;),
                        (&#x27;1981-07&#x27;,&#x27;1982-11&#x27;), (&#x27;1990-07&#x27;,&#x27;1991-03&#x27;),
                        (&#x27;2001-03&#x27;,&#x27;2001-11&#x27;)]:
        ax.axvspan(pd.Timestamp(start), pd.Timestamp(end),
                   alpha=0.08, color=&#x27;grey&#x27;)

axes[-1].set_xlabel(&#x27;Date&#x27;)
fig.suptitle(&#x27;Kilian (2009) Oil Market Variables&#x27;, fontsize=15, fontweight=&#x27;bold&#x27;, y=1.01)
plt.tight_layout()
plt.savefig(&#x27;fig01_timeseries.png&#x27;, dpi=150, bbox_inches=&#x27;tight&#x27;)
plt.show()
print(&quot;Grey shaded areas = approximate NBER recession periods.&quot;)</div>
<div class="output-img"><img src="assets/img/nb_img_00.png" alt="Output figure" loading="lazy"></div>
<div class="output-wrap"><span class="output-label">Output</span>Grey shaded areas = approximate NBER recession periods.
</div>
</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [5]</span></div>
<div class="code-block"># ── Distributions &amp; boxplots ─────────────────────────────────
fig, axes = plt.subplots(1, 3, figsize=(14, 4.5))

for ax, var, title, color in zip(axes, variables, titles, colors):
    sns.histplot(df[var], kde=True, ax=ax, color=color, alpha=0.6, bins=35)
    ax.axvline(df[var].mean(), color=&#x27;red&#x27;, linestyle=&#x27;--&#x27;, linewidth=1.2, label=f&#x27;Mean={df[var].mean():.2f}&#x27;)
    ax.axvline(df[var].median(), color=&#x27;navy&#x27;, linestyle=&#x27;:&#x27;, linewidth=1.2, label=f&#x27;Median={df[var].median():.2f}&#x27;)
    ax.set_title(title, fontweight=&#x27;bold&#x27;, fontsize=10)
    ax.legend(fontsize=8)

plt.suptitle(&#x27;Marginal Distributions&#x27;, fontsize=13, fontweight=&#x27;bold&#x27;)
plt.tight_layout()
plt.savefig(&#x27;fig02_distributions.png&#x27;, dpi=150, bbox_inches=&#x27;tight&#x27;)
plt.show()</div>
<div class="output-img"><img src="assets/img/nb_img_01.png" alt="Output figure" loading="lazy"></div>
</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [6]</span></div>
<div class="code-block"># ── Correlation heatmap &amp; scatter matrix ─────────────────────
fig, axes = plt.subplots(1, 2, figsize=(14, 5))

# Heatmap
mask = np.triu(np.ones_like(corr, dtype=bool), k=1)
sns.heatmap(corr, annot=True, fmt=&#x27;.4f&#x27;, cmap=&#x27;RdBu_r&#x27;, center=0,
            vmin=-1, vmax=1, ax=axes[0], square=True, mask=mask,
            linewidths=1, cbar_kws={&#x27;shrink&#x27;: 0.8})
axes[0].set_title(&#x27;Correlation Matrix&#x27;, fontweight=&#x27;bold&#x27;)

# Scatter: rea vs rpo (highest correlation)
axes[1].scatter(df[&#x27;rea&#x27;], df[&#x27;rpo&#x27;], alpha=0.4, s=15, c=&#x27;#FF5722&#x27;, edgecolor=&#x27;none&#x27;)
z = np.polyfit(df[&#x27;rea&#x27;], df[&#x27;rpo&#x27;], 1)
p = np.poly1d(z)
x_line = np.linspace(df[&#x27;rea&#x27;].min(), df[&#x27;rea&#x27;].max(), 100)
axes[1].plot(x_line, p(x_line), &#x27;k--&#x27;, linewidth=1.5, label=f&#x27;OLS: ρ={corr.loc[&quot;rea&quot;,&quot;rpo&quot;]:.4f}&#x27;)
axes[1].set_xlabel(&#x27;Real Economic Activity&#x27;)
axes[1].set_ylabel(&#x27;Real Price of Oil&#x27;)
axes[1].set_title(&#x27;REA vs RPO&#x27;, fontweight=&#x27;bold&#x27;)
axes[1].legend()

plt.tight_layout()
plt.savefig(&#x27;fig03_correlations.png&#x27;, dpi=150, bbox_inches=&#x27;tight&#x27;)
plt.show()</div>
<div class="output-img"><img src="assets/img/nb_img_02.png" alt="Output figure" loading="lazy"></div>
</div>
</div>
<div class="nb-cell nb-md">
<h2 id="nb-s16">4. Cumulated Series (Level Variables)</h2>

<p>Kilian&#x27;s variables are in first-differences / stationary form. For cointegration analysis we also examine the <strong>cumulated</strong> (level) series, which are I(1) by construction:</p>

<div class="formula-box">$$\text{dprod\_cum}_t = \sum_{s=1}^{t} \Delta\text{prod}_s, \qquad \text{rea\_cum}_t = \sum_{s=1}^{t} \text{rea}_s, \qquad \text{rpo\_cum}_t = \sum_{s=1}^{t} \text{rpo}_s$$</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [7]</span></div>
<div class="code-block"># ── Cumulated (level) series ─────────────────────────────────
df[&#x27;dprod_cum&#x27;] = np.cumsum(df[&#x27;dprod&#x27;].values)
df[&#x27;rea_cum&#x27;]   = np.cumsum(df[&#x27;rea&#x27;].values)
df[&#x27;rpo_cum&#x27;]   = np.cumsum(df[&#x27;rpo&#x27;].values)

fig, axes = plt.subplots(3, 1, figsize=(14, 10), sharex=True)
cum_vars   = [&#x27;dprod_cum&#x27;, &#x27;rea_cum&#x27;, &#x27;rpo_cum&#x27;]
cum_titles = [&#x27;Cumulated Oil Production Growth&#x27;,
              &#x27;Cumulated Real Economic Activity&#x27;,
              &#x27;Cumulated Real Price of Oil&#x27;]

for ax, var, title, color in zip(axes, cum_vars, cum_titles, colors):
    ax.plot(df.index, df[var], color=color, linewidth=1.2)
    ax.set_title(title, fontweight=&#x27;bold&#x27;)
    ax.set_ylabel(var)

axes[-1].set_xlabel(&#x27;Date&#x27;)
fig.suptitle(&#x27;Cumulated (I(1)) Series&#x27;, fontsize=15, fontweight=&#x27;bold&#x27;, y=1.01)
plt.tight_layout()
plt.savefig(&#x27;fig04_cumulated.png&#x27;, dpi=150, bbox_inches=&#x27;tight&#x27;)
plt.show()</div>
<div class="output-img"><img src="assets/img/nb_img_03.png" alt="Output figure" loading="lazy"></div>
</div>
</div>
<div class="nb-cell nb-md">
<hr>
<h2 id="nb-s18">5. Segmented Cointegration Tests</h2>

<h3>5.1 Theoretical Background</h3>

<p>Standard cointegration tests assume the cointegrating relationship holds over the <strong>entire sample</strong>. However, the relationship may only hold during certain sub-periods (regimes) and break down temporarily. Kim (2003) formalises this as <strong>segmented cointegration</strong>:</p>

<div class="formula-box">$$x_{1t} = \alpha + \beta' x_{2t} + \varepsilon_t$$</div>

<p>where $\varepsilon_t$ has autoregressive root $\rho_t$:</p>

<div class="formula-box">$$\rho_t = \begin{cases} \rho < 1 & \text{if } t \in C_T \text{ (cointegration period)} \\ 1 & \text{if } t \in N_T \text{ (non-cointegration period)} \end{cases}$$</div>

<p>We apply two complementary test procedures:</p>

<table>
<tr><th>Test</th><th>Null Hypothesis</th><th>Alternative</th><th>Key Statistics</th></tr>
<p>|------|----------------|-------------|----------------|</p>
<tr><td>**Kim (2003)**</td><td>$H_0$: $\rho = 1$ for all $t$</td><td>$H_1$: segmented coint.</td><td>$Z^*_\rho$, $Z^*_t$, $ADF^*_\rho$, $ADF^*_t$</td></tr>
<tr><td>**Martins &amp; Rodrigues (2022)**</td><td>$H_0$: no cointegration</td><td>$H_1$: $m^*$ breaks</td><td>$W(m^*)$, $W_{\max}$</td></tr>
</table>
</div>
<div class="nb-cell nb-md">
<h3>5.2 Test Configurations</h3>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [8]</span></div>
<div class="code-block"># ── Define all test configurations ───────────────────────────
# We test multiple specifications systematically

configs = [
    # (label, y_col, X_cols, use_cum, model)
    (&quot;A: rpo ~ rea&quot;,             &#x27;rpo&#x27;,     [&#x27;rea&#x27;],          False, &#x27;drift&#x27;),
    (&quot;B: rpo ~ dprod&quot;,           &#x27;rpo&#x27;,     [&#x27;dprod&#x27;],        False, &#x27;drift&#x27;),
    (&quot;C: rpo ~ dprod + rea&quot;,     &#x27;rpo&#x27;,     [&#x27;dprod&#x27;, &#x27;rea&#x27;], False, &#x27;drift&#x27;),
    (&quot;D: rpo_cum ~ rea_cum&quot;,     &#x27;rpo_cum&#x27;, [&#x27;rea_cum&#x27;],      True,  &#x27;drift&#x27;),
    (&quot;E: rpo_cum ~ dprod_cum&quot;,   &#x27;rpo_cum&#x27;, [&#x27;dprod_cum&#x27;],    True,  &#x27;drift&#x27;),
    (&quot;F: rpo_cum ~ dprod_cum + rea_cum&quot;,
                                 &#x27;rpo_cum&#x27;, [&#x27;dprod_cum&#x27;, &#x27;rea_cum&#x27;], True, &#x27;drift&#x27;),
]

print(tabulate(
    [[c[0], c[1], &#x27; + &#x27;.join(c[2]), &#x27;Cumulated&#x27; if c[3] else &#x27;Raw&#x27;, c[4]]
     for c in configs],
    headers=[&#x27;Config&#x27;, &#x27;Dependent (y)&#x27;, &#x27;Regressors (X)&#x27;, &#x27;Type&#x27;, &#x27;Model&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, showindex=False
))</div>
<div class="output-wrap"><span class="output-label">Output</span>╒══════════════════════════════════╤═════════════════╤═════════════════════╤═══════════╤═════════╕
│ Config                           │ Dependent (y)   │ Regressors (X)      │ Type      │ Model   │
╞══════════════════════════════════╪═════════════════╪═════════════════════╪═══════════╪═════════╡
│ A: rpo ~ rea                     │ rpo             │ rea                 │ Raw       │ drift   │
├──────────────────────────────────┼─────────────────┼─────────────────────┼───────────┼─────────┤
│ B: rpo ~ dprod                   │ rpo             │ dprod               │ Raw       │ drift   │
├──────────────────────────────────┼─────────────────┼─────────────────────┼───────────┼─────────┤
│ C: rpo ~ dprod + rea             │ rpo             │ dprod + rea         │ Raw       │ drift   │
├──────────────────────────────────┼─────────────────┼─────────────────────┼───────────┼─────────┤
│ D: rpo_cum ~ rea_cum             │ rpo_cum         │ rea_cum             │ Cumulated │ drift   │
├──────────────────────────────────┼─────────────────┼─────────────────────┼───────────┼─────────┤
│ E: rpo_cum ~ dprod_cum           │ rpo_cum         │ dprod_cum           │ Cumulated │ drift   │
├──────────────────────────────────┼─────────────────┼─────────────────────┼───────────┼─────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ rpo_cum         │ dprod_cum + rea_cum │ Cumulated │ drift   │
╘══════════════════════════════════╧═════════════════╧═════════════════════╧═══════════╧═════════╛
</div>
</div>
</div>
<div class="nb-cell nb-md">
<h3>5.3 Kim (2003) — Infimum-Based Tests</h3>

<p>The Kim (2003) procedure searches over all admissible segmentations $N_T$ of length $\leq \bar{\ell}(T_N) \cdot T$ and computes the <strong>infimum</strong> of four test statistics over the cointegration subset $C_T = \{1,...,T\} \setminus N_T$:</p>

<div class="formula-box">$$Z^*_\rho = \inf_{C_T} Z_\rho(C_T), \quad Z^*_t = \inf_{C_T} Z_t(C_T)$$</div>
<div class="formula-box">$$ADF^*_\rho = \inf_{C_T} ADF_\rho(C_T), \quad ADF^*_t = \inf_{C_T} ADF_t(C_T)$$</div>

<p>Critical values are from Kim (2003, Tables 1–2) with $\bar{\ell}(T_N) = 0.30$.</p>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [9]</span></div>
<div class="code-block"># ── Run Kim (2003) tests for all configurations ──────────────
kim_results = {}

for label, y_col, x_cols, _, model in configs:
    y = df[y_col].values
    X = df[x_cols].values if len(x_cols) &gt; 1 else df[x_cols[0]].values.reshape(-1, 1)
    
    print(f&quot;▸ Running Kim test: {label} ...&quot;, end=&quot; &quot;, flush=True)
    res = kim_test(y, X, model=model, max_ell=0.3, step=2)
    kim_results[label] = res
    print(&quot;done&quot;)

print(&quot;\n✓ All Kim (2003) tests completed.&quot;)</div>
<div class="output-wrap"><span class="output-label">Output</span>▸ Running Kim test: A: rpo ~ rea ... done
▸ Running Kim test: B: rpo ~ dprod ... done
▸ Running Kim test: C: rpo ~ dprod + rea ... done
▸ Running Kim test: D: rpo_cum ~ rea_cum ... done
▸ Running Kim test: E: rpo_cum ~ dprod_cum ... done
▸ Running Kim test: F: rpo_cum ~ dprod_cum + rea_cum ... done

✓ All Kim (2003) tests completed.
</div>
</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [10]</span></div>
<div class="code-block"># ── Kim (2003) — Summary Table of All Configurations ────────
rows_table = []
for label, res in kim_results.items():
    for stat in [&#x27;Zp&#x27;, &#x27;Zt&#x27;, &#x27;ADFp&#x27;, &#x27;ADFt&#x27;]:
        val = res.infimum_stats[stat]
        cv5 = res.critical_values[stat][0.05]
        sig = &#x27;**&#x27; if res.significant(stat, 0.05) else (
              &#x27;*&#x27;  if res.significant(stat, 0.10) else &#x27;&#x27;)
        t0, t1 = res.break_fractions(stat)
        rows_table.append([
            label, stat, f&quot;{val:.4f}&quot;, f&quot;{cv5:.4f}&quot;, sig,
            f&quot;({t0:.3f}, {t1:.3f})&quot;
        ])

print(tabulate(
    rows_table,
    headers=[&#x27;Config&#x27;, &#x27;Stat&#x27;, &#x27;Inf. Value&#x27;, &#x27;5% CV&#x27;, &#x27;Sig.&#x27;, &#x27;Break (τ₀, τ₁)&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, showindex=False
))
print(&quot;\nNotes: ** p &lt; 0.05, * p &lt; 0.10&quot;)</div>
<div class="output-wrap"><span class="output-label">Output</span>╒══════════════════════════════════╤════════╤══════════════╤═════════╤════════╤══════════════════╕
│ Config                           │ Stat   │   Inf. Value │   5% CV │ Sig.   │ Break (τ₀, τ₁)   │
╞══════════════════════════════════╪════════╪══════════════╪═════════╪════════╪══════════════════╡
│ A: rpo ~ rea                     │ Zp     │     -16.5547 │  -50.75 │        │ (0.205, 0.356)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ A: rpo ~ rea                     │ Zt     │      -3.0007 │   -6.36 │        │ (0.205, 0.356)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ A: rpo ~ rea                     │ ADFp   │     -16.3362 │  -50.75 │        │ (0.095, 0.360)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ A: rpo ~ rea                     │ ADFt   │      -2.8365 │   -6.36 │        │ (0.095, 0.360)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ B: rpo ~ dprod                   │ Zp     │     -13.3635 │  -50.75 │        │ (0.730, 0.742)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ B: rpo ~ dprod                   │ Zt     │      -2.4854 │   -6.36 │        │ (0.730, 0.742)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ B: rpo ~ dprod                   │ ADFp   │     -12.7214 │  -50.75 │        │ (0.678, 0.742)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ B: rpo ~ dprod                   │ ADFt   │      -2.6933 │   -6.36 │        │ (0.516, 0.742)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ C: rpo ~ dprod + rea             │ Zp     │     -16.6549 │  -65.53 │        │ (0.205, 0.356)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ C: rpo ~ dprod + rea             │ Zt     │      -3.006  │   -7.38 │        │ (0.205, 0.356)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ C: rpo ~ dprod + rea             │ ADFp   │     -16.1741 │  -65.53 │        │ (0.177, 0.360)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ C: rpo ~ dprod + rea             │ ADFt   │      -2.804  │   -7.38 │        │ (0.558, 0.742)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ D: rpo_cum ~ rea_cum             │ Zp     │      -4.4936 │  -50.75 │        │ (0.053, 0.055)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ D: rpo_cum ~ rea_cum             │ Zt     │      -1.0815 │   -6.36 │        │ (0.053, 0.060)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ D: rpo_cum ~ rea_cum             │ ADFp   │      -9.076  │  -50.75 │        │ (0.453, 0.508)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ D: rpo_cum ~ rea_cum             │ ADFt   │      -2.8223 │   -6.36 │        │ (0.453, 0.508)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ E: rpo_cum ~ dprod_cum           │ Zp     │     -14.6938 │  -50.75 │        │ (0.005, 0.064)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ E: rpo_cum ~ dprod_cum           │ Zt     │      -3.0918 │   -6.36 │        │ (0.005, 0.064)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ E: rpo_cum ~ dprod_cum           │ ADFp   │      -9.522  │  -50.75 │        │ (0.038, 0.064)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ E: rpo_cum ~ dprod_cum           │ ADFt   │      -3.2021 │   -6.36 │        │ (0.038, 0.064)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ Zp     │     -13.9169 │  -65.53 │        │ (0.024, 0.064)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ Zt     │      -3.0049 │   -7.38 │        │ (0.005, 0.064)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ ADFp   │      -9.156  │  -65.53 │        │ (0.038, 0.064)   │
├──────────────────────────────────┼────────┼──────────────┼─────────┼────────┼──────────────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ ADFt   │      -3.2362 │   -7.38 │        │ (0.038, 0.064)   │
╘══════════════════════════════════╧════════╧══════════════╧═════════╧════════╧══════════════════╛

Notes: ** p &lt; 0.05, * p &lt; 0.10
</div>
</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [11]</span></div>
<div class="code-block"># ── Kim (2003) — Detailed Results for Key Specifications ────
for label in [&quot;C: rpo ~ dprod + rea&quot;, &quot;F: rpo_cum ~ dprod_cum + rea_cum&quot;]:
    res = kim_results[label]
    print(&quot;═&quot; * 70)
    print(res.summary())
    print()</div>
<div class="output-wrap"><span class="output-label">Output</span>══════════════════════════════════════════════════════════════════════
========================================================================
Kim (2003) Segmented Cointegration Test Results
========================================================================
Model:            Case II (intercept)
Sample size (T):  419
Variables (n):    3
Max ell (T_N):    0.30
ADF lag order:    12

------------------------------------------------------------------------
Statistic      Inf. Value  Full Sample       5% CV  Reject H0     tau_0    tau_1
------------------------------------------------------------------------
Zp*              -16.6549     -10.9193    -65.5300         No     0.205    0.356
Zt*               -3.0060      -2.4623     -7.3800         No     0.205    0.356
ADFp*            -16.1741     -10.3283    -65.5300         No     0.177    0.360
ADFt*             -2.8040      -2.0346     -7.3800         No     0.558    0.742
------------------------------------------------------------------------
Notes: Infimum statistics are Z*_rho, Z*_t, ADF*_rho, ADF*_t
       from Kim (2003, Eqs. 3.13-3.14).
       Critical values from Tables 1-2 for ell_bar(T_N)=0.3.
       Reject H0 implies segmented cointegration detected.
========================================================================

══════════════════════════════════════════════════════════════════════
========================================================================
Kim (2003) Segmented Cointegration Test Results
========================================================================
Model:            Case II (intercept)
Sample size (T):  419
Variables (n):    3
Max ell (T_N):    0.30
ADF lag order:    12

------------------------------------------------------------------------
Statistic      Inf. Value  Full Sample       5% CV  Reject H0     tau_0    tau_1
------------------------------------------------------------------------
Zp*              -13.9169      -4.8613    -65.5300         No     0.024    0.064
Zt*               -3.0049      -2.0102     -7.3800         No     0.005    0.064
ADFp*             -9.1560      -6.0629    -65.5300         No     0.038    0.064
ADFt*             -3.2362      -2.2152     -7.3800         No     0.038    0.064
------------------------------------------------------------------------
Notes: Infimum statistics are Z*_rho, Z*_t, ADF*_rho, ADF*_t
       from Kim (2003, Eqs. 3.13-3.14).
       Critical values from Tables 1-2 for ell_bar(T_N)=0.3.
       Reject H0 implies segmented cointegration detected.
========================================================================

</div>
</div>
</div>
<div class="nb-cell nb-md">
<h3>5.4 Martins &amp; Rodrigues (2022) — Wald-Type Tests</h3>

<p>The MR (2022) procedure uses <strong>sup-Wald-type</strong> statistics to test for segmented cointegration with $m^*$ structural breaks. Two hypotheses are considered:</p>

<li>**$H_{1A}$**: First regime is $I(1)$ → switches to $I(0)$ → back to $I(1)$ → ...</li>
<li>**$H_{1B}$**: First regime is $I(0)$ → switches to $I(1)$ → back to $I(0)$ → ...</li>

<div class="formula-box">$$W(m^*) = \max\{\sup F_A(m^*),\; \sup F_B(m^*)\}, \qquad W_{\max} = \max_{1 \leq m \leq \bar{m}} W(m)$$</div>

<p>Trimming parameter $\varepsilon = 0.15$ ensures each regime has at least $15\%$ of the sample.</p>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [12]</span></div>
<div class="code-block"># ── Run Martins &amp; Rodrigues (2022) tests ─────────────────────
mr_results = {}

for label, y_col, x_cols, _, model in configs:
    y = df[y_col].values
    X = df[x_cols].values if len(x_cols) &gt; 1 else df[x_cols[0]].values.reshape(-1, 1)
    
    print(f&quot;▸ Running MR test: {label} ...&quot;, end=&quot; &quot;, flush=True)
    res = mr_test(y, X, model=model, max_breaks=3, epsilon=0.15, step=2)
    mr_results[label] = res
    print(&quot;done&quot;)

print(&quot;\n✓ All Martins &amp; Rodrigues (2022) tests completed.&quot;)</div>
<div class="output-wrap"><span class="output-label">Output</span>▸ Running MR test: A: rpo ~ rea ... done
▸ Running MR test: B: rpo ~ dprod ... done
▸ Running MR test: C: rpo ~ dprod + rea ... done
▸ Running MR test: D: rpo_cum ~ rea_cum ... done
▸ Running MR test: E: rpo_cum ~ dprod_cum ... done
▸ Running MR test: F: rpo_cum ~ dprod_cum + rea_cum ... done

✓ All Martins &amp; Rodrigues (2022) tests completed.
</div>
</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [13]</span></div>
<div class="code-block"># ── MR (2022) — Summary Table of All Configurations ────────
rows_mr = []
for label, res in mr_results.items():
    for m in sorted(res.W_stats.keys()):
        w_val = res.W_stats[m]
        cv5 = res.critical_values.get(m, {}).get(0.05, float(&#x27;nan&#x27;))
        cv10 = res.critical_values.get(m, {}).get(0.10, float(&#x27;nan&#x27;))
        sig = &#x27;**&#x27; if w_val &gt; cv5 else (&#x27;*&#x27; if w_val &gt; cv10 else &#x27;&#x27;)
        rows_mr.append([label, f&quot;W({m})&quot;, f&quot;{w_val:.4f}&quot;, f&quot;{cv5:.4f}&quot;, sig])
    
    # W_max
    cv5_wmax = res.critical_values.get(&#x27;Wmax&#x27;, {}).get(0.05, float(&#x27;nan&#x27;))
    cv10_wmax = res.critical_values.get(&#x27;Wmax&#x27;, {}).get(0.10, float(&#x27;nan&#x27;))
    sig_wmax = &#x27;**&#x27; if res.W_max &gt; cv5_wmax else (&#x27;*&#x27; if res.W_max &gt; cv10_wmax else &#x27;&#x27;)
    rows_mr.append([label, f&quot;W_max&quot;, f&quot;{res.W_max:.4f}&quot;, f&quot;{cv5_wmax:.4f}&quot;, sig_wmax])
    rows_mr.append([&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;])

print(tabulate(
    rows_mr,
    headers=[&#x27;Config&#x27;, &#x27;Test&#x27;, &#x27;Statistic&#x27;, &#x27;5% CV&#x27;, &#x27;Sig.&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, showindex=False
))
print(&quot;\nNotes: ** p &lt; 0.05, * p &lt; 0.10&quot;)</div>
<div class="output-wrap"><span class="output-label">Output</span>╒══════════════════════════════════╤════════╤═════════════╤═════════╤════════╕
│ Config                           │ Test   │ Statistic   │ 5% CV   │ Sig.   │
╞══════════════════════════════════╪════════╪═════════════╪═════════╪════════╡
│ A: rpo ~ rea                     │ W(1)   │ 5.9991      │ 9.1060  │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ A: rpo ~ rea                     │ W(2)   │ 12.9595     │ 9.2770  │ **     │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ A: rpo ~ rea                     │ W(3)   │ 8.5779      │ 7.7640  │ **     │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ A: rpo ~ rea                     │ W_max  │ 12.9595     │ nan     │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│                                  │        │             │         │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ B: rpo ~ dprod                   │ W(1)   │ 10.3457     │ 9.1060  │ **     │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ B: rpo ~ dprod                   │ W(2)   │ 14.4660     │ 9.2770  │ **     │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ B: rpo ~ dprod                   │ W(3)   │ 15.8329     │ 7.7640  │ **     │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ B: rpo ~ dprod                   │ W_max  │ 15.8329     │ nan     │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│                                  │        │             │         │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ C: rpo ~ dprod + rea             │ W(1)   │ 6.0862      │ 8.7610  │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ C: rpo ~ dprod + rea             │ W(2)   │ 12.4415     │ 9.0900  │ **     │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ C: rpo ~ dprod + rea             │ W(3)   │ 8.3917      │ 7.6450  │ **     │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ C: rpo ~ dprod + rea             │ W_max  │ 12.4415     │ nan     │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│                                  │        │             │         │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ D: rpo_cum ~ rea_cum             │ W(1)   │ 8.6579      │ 9.1060  │ *      │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ D: rpo_cum ~ rea_cum             │ W(2)   │ 8.4881      │ 9.2770  │ *      │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ D: rpo_cum ~ rea_cum             │ W(3)   │ 8.4529      │ 7.7640  │ **     │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ D: rpo_cum ~ rea_cum             │ W_max  │ 8.6579      │ nan     │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│                                  │        │             │         │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ E: rpo_cum ~ dprod_cum           │ W(1)   │ 5.7297      │ 9.1060  │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ E: rpo_cum ~ dprod_cum           │ W(2)   │ 10.0776     │ 9.2770  │ **     │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ E: rpo_cum ~ dprod_cum           │ W(3)   │ 7.4269      │ 7.7640  │ *      │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ E: rpo_cum ~ dprod_cum           │ W_max  │ 10.0776     │ nan     │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│                                  │        │             │         │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ W(1)   │ 5.7978      │ 8.7610  │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ W(2)   │ 10.5888     │ 9.0900  │ **     │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ W(3)   │ 7.9761      │ 7.6450  │ **     │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ W_max  │ 10.5888     │ nan     │        │
├──────────────────────────────────┼────────┼─────────────┼─────────┼────────┤
│                                  │        │             │         │        │
╘══════════════════════════════════╧════════╧═════════════╧═════════╧════════╛

Notes: ** p &lt; 0.05, * p &lt; 0.10
</div>
</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [14]</span></div>
<div class="code-block"># ── MR (2022) — Detailed results for key specifications ─────
for label in [&quot;C: rpo ~ dprod + rea&quot;, &quot;F: rpo_cum ~ dprod_cum + rea_cum&quot;]:
    res = mr_results[label]
    print(&quot;═&quot; * 72)
    print(res.summary())
    print()</div>
<div class="output-wrap"><span class="output-label">Output</span>════════════════════════════════════════════════════════════════════════
==============================================================================
Martins &amp; Rodrigues (2022) Wald-Type Tests for Segmented Cointegration
==============================================================================
Model:            Intercept only
Sample size (T):  419
Variables (K+1):  3
Trimming (eps):   0.15
Max breaks:       3
ADF lag order:    12

------------------------------------------------------------------------------
Test          Statistic      10% CV      5% CV      1% CV   Reject 5%
------------------------------------------------------------------------------
W(1)           6.0862       7.711      8.761     11.103          No
W(2)          12.4415       8.036      9.090     11.470       Yes**
W(3)           8.3917       6.830      7.645      9.855       Yes**
W_max          12.4415       9.214     10.552     13.973       Yes**
------------------------------------------------------------------------------

Estimated break dates (for W_max):
  Number of breaks:  2
  First regime:      I(1) (H1A)
  Break dates:       (143, 350)
  Break fractions:   (0.3413, 0.8353)

Notes: W(m*) = max(sup F_A(m*), sup F_B(m*)).
       W_max = max_{1&lt;=m&lt;=m_bar} W(m).
       Critical values from Martins &amp; Rodrigues (2022, Table 1).
==============================================================================

════════════════════════════════════════════════════════════════════════
==============================================================================
Martins &amp; Rodrigues (2022) Wald-Type Tests for Segmented Cointegration
==============================================================================
Model:            Intercept only
Sample size (T):  419
Variables (K+1):  3
Trimming (eps):   0.15
Max breaks:       3
ADF lag order:    12

------------------------------------------------------------------------------
Test          Statistic      10% CV      5% CV      1% CV   Reject 5%
------------------------------------------------------------------------------
W(1)           5.7978       7.711      8.761     11.103          No
W(2)          10.5888       8.036      9.090     11.470       Yes**
W(3)           7.9761       6.830      7.645      9.855       Yes**
W_max          10.5888       9.214     10.552     13.973       Yes**
------------------------------------------------------------------------------

Estimated break dates (for W_max):
  Number of breaks:  2
  First regime:      I(1) (H1A)
  Break dates:       (109, 216)
  Break fractions:   (0.2601, 0.5155)

Notes: W(m*) = max(sup F_A(m*), sup F_B(m*)).
       W_max = max_{1&lt;=m&lt;=m_bar} W(m).
       Critical values from Martins &amp; Rodrigues (2022, Table 1).
==============================================================================

</div>
</div>
</div>
<div class="nb-cell nb-md">
<hr>
<h2 id="nb-s29">6. Estimated Break Dates</h2>

<p>When segmented cointegration is detected, the estimated <strong>structural break dates</strong> divide the sample into regimes of cointegration and non-cointegration. We map observation indices back to calendar dates.</p>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [15]</span></div>
<div class="code-block"># ── Estimated break dates from MR (2022) ────────────────────
break_table = []
for label, res in mr_results.items():
    m_star = res.W_max_m
    if m_star in res.best_breaks:
        breaks = res.best_breaks[m_star][&#x27;breaks&#x27;]
        hyp = res.best_breaks[m_star].get(&#x27;hypothesis&#x27;, &#x27;N/A&#x27;)
        break_dates_str = []
        for b in breaks:
            if b &lt; len(df):
                break_dates_str.append(df.index[b].strftime(&#x27;%Y:%m&#x27;))
            else:
                break_dates_str.append(f&quot;obs {b}&quot;)
        fracs = [f&quot;{b/T:.3f}&quot; for b in breaks]
        break_table.append([
            label, m_star, hyp,
            &#x27;, &#x27;.join(break_dates_str),
            &#x27;, &#x27;.join(fracs),
            f&quot;{res.W_max:.4f}&quot;
        ])

print(tabulate(
    break_table,
    headers=[&#x27;Config&#x27;, &#x27;m*&#x27;, &#x27;Hyp&#x27;, &#x27;Break Dates&#x27;, &#x27;Fractions&#x27;, &#x27;W_max&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, showindex=False
))</div>
<div class="output-wrap"><span class="output-label">Output</span>╒══════════════════════════════════╤══════╤═══════╤═══════════════════════════╤═════════════════════╤═════════╕
│ Config                           │   m* │ Hyp   │ Break Dates               │ Fractions           │   W_max │
╞══════════════════════════════════╪══════╪═══════╪═══════════════════════════╪═════════════════════╪═════════╡
│ A: rpo ~ rea                     │    2 │ A     │ 1985:01, 2002:04          │ 0.341, 0.835        │ 12.9595 │
├──────────────────────────────────┼──────┼───────┼───────────────────────────┼─────────────────────┼─────────┤
│ B: rpo ~ dprod                   │    3 │ B     │ 1978:05, 1985:02, 1990:09 │ 0.150, 0.344, 0.504 │ 15.8329 │
├──────────────────────────────────┼──────┼───────┼───────────────────────────┼─────────────────────┼─────────┤
│ C: rpo ~ dprod + rea             │    2 │ A     │ 1985:01, 2002:04          │ 0.341, 0.835        │ 12.4415 │
├──────────────────────────────────┼──────┼───────┼───────────────────────────┼─────────────────────┼─────────┤
│ D: rpo_cum ~ rea_cum             │    1 │ A     │ 1986:07                   │ 0.384               │  8.6579 │
├──────────────────────────────────┼──────┼───────┼───────────────────────────┼─────────────────────┼─────────┤
│ E: rpo_cum ~ dprod_cum           │    2 │ A     │ 1982:03, 1991:02          │ 0.260, 0.516        │ 10.0776 │
├──────────────────────────────────┼──────┼───────┼───────────────────────────┼─────────────────────┼─────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │    2 │ A     │ 1982:03, 1991:02          │ 0.260, 0.516        │ 10.5888 │
╘══════════════════════════════════╧══════╧═══════╧═══════════════════════════╧═════════════════════╧═════════╛
</div>
</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [16]</span></div>
<div class="code-block"># ── Kim (2003) Break Estimator (Extremum) ────────────────────
print(&quot;Kim (2003) Extremum Break Estimator: argmax Λ_T(τ)&quot;)
print(&quot;─&quot; * 60)

kim_break_table = []
for label, y_col, x_cols, _, model in configs:
    y = df[y_col].values
    X = df[x_cols].values if len(x_cols) &gt; 1 else df[x_cols[0]].values.reshape(-1, 1)
    
    be = kim_break_estimator(y, X, model=model, step=2)
    t0, t1 = be[&#x27;tau_hat&#x27;]
    k0, k1 = be[&#x27;k0_hat&#x27;], be[&#x27;k1_hat&#x27;]
    lam = be[&#x27;Lambda_max&#x27;]
    
    d0 = df.index[k0].strftime(&#x27;%Y:%m&#x27;) if k0 &lt; len(df) else f&quot;obs {k0}&quot;
    d1 = df.index[min(k1, len(df)-1)].strftime(&#x27;%Y:%m&#x27;)
    
    kim_break_table.append([label, f&quot;({t0:.3f}, {t1:.3f})&quot;, f&quot;({d0}, {d1})&quot;, f&quot;{lam:.4f}&quot;])

print(tabulate(
    kim_break_table,
    headers=[&#x27;Config&#x27;, &#x27;(τ̂₀, τ̂₁)&#x27;, &#x27;Break Dates&#x27;, &#x27;Λ_max&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, showindex=False
))</div>
<div class="output-wrap"><span class="output-label">Output</span>Kim (2003) Extremum Break Estimator: argmax Λ_T(τ)
────────────────────────────────────────────────────────────
╒══════════════════════════════════╤════════════════╤════════════════════╤═════════╕
│ Config                           │ (τ̂₀, τ̂₁)       │ Break Dates        │   Λ_max │
╞══════════════════════════════════╪════════════════╪════════════════════╪═════════╡
│ A: rpo ~ rea                     │ (0.740, 0.742) │ (1998:12, 1999:01) │  5.3014 │
├──────────────────────────────────┼────────────────┼────────────────────┼─────────┤
│ B: rpo ~ dprod                   │ (0.740, 0.742) │ (1998:12, 1999:01) │  6.5067 │
├──────────────────────────────────┼────────────────┼────────────────────┼─────────┤
│ C: rpo ~ dprod + rea             │ (0.740, 0.742) │ (1998:12, 1999:01) │  5.336  │
├──────────────────────────────────┼────────────────┼────────────────────┼─────────┤
│ D: rpo_cum ~ rea_cum             │ (0.053, 0.055) │ (1974:12, 1975:01) │  3.855  │
├──────────────────────────────────┼────────────────┼────────────────────┼─────────┤
│ E: rpo_cum ~ dprod_cum           │ (0.062, 0.064) │ (1975:04, 1975:05) │  7.4634 │
├──────────────────────────────────┼────────────────┼────────────────────┼─────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ (0.062, 0.064) │ (1975:04, 1975:05) │  7.4112 │
╘══════════════════════════════════╧════════════════╧════════════════════╧═════════╛
</div>
</div>
</div>
<div class="nb-cell nb-md">
<h2 id="nb-s32">7. Visualisation of Regime Breaks</h2>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [17]</span></div>
<div class="code-block"># ── Regime plot: rpo ~ dprod + rea (Config C) ────────────────
label = &quot;C: rpo ~ dprod + rea&quot;
res_mr_c = mr_results[label]
res_kim_c = kim_results[label]

fig, axes = plt.subplots(3, 1, figsize=(14, 11), sharex=True)

for ax, var, title, color in zip(axes, variables, titles, colors):
    ax.plot(df.index, df[var], color=color, linewidth=0.9, alpha=0.85)
    ax.set_title(title, fontweight=&#x27;bold&#x27;)
    ax.set_ylabel(var)

# Add MR break dates
m_star = res_mr_c.W_max_m
if m_star in res_mr_c.best_breaks:
    breaks = res_mr_c.best_breaks[m_star][&#x27;breaks&#x27;]
    hyp = res_mr_c.best_breaks[m_star].get(&#x27;hypothesis&#x27;, &#x27;H1A&#x27;)
    
    for b in breaks:
        if b &lt; len(df):
            for ax in axes:
                ax.axvline(x=df.index[b], color=&#x27;red&#x27;, linewidth=2, linestyle=&#x27;--&#x27;, alpha=0.8)
    
    # Shade regimes
    all_bounds = [0] + list(breaks) + [T-1]
    is_I1 = (hyp == &#x27;H1A&#x27;)  # first regime is I(1) for H1A
    
    for i in range(len(all_bounds) - 1):
        start_idx = all_bounds[i]
        end_idx   = min(all_bounds[i+1], T-1)
        start_dt  = df.index[start_idx]
        end_dt    = df.index[end_idx]
        
        if is_I1:
            for ax in axes:
                ax.axvspan(start_dt, end_dt, alpha=0.06, color=&#x27;red&#x27;,
                          label=&#x27;Non-coint. I(1)&#x27; if i == 0 else &#x27;&#x27;)
        else:
            for ax in axes:
                ax.axvspan(start_dt, end_dt, alpha=0.10, color=&#x27;green&#x27;,
                          label=&#x27;Coint. I(0)&#x27; if i == 0 else &#x27;&#x27;)
        is_I1 = not is_I1

axes[0].legend(loc=&#x27;upper left&#x27;, fontsize=9)

fig.suptitle(f&#x27;Segmented Cointegration Regimes — {label}\n&#x27;
             f&#x27;MR (2022): W_max = {res_mr_c.W_max:.4f}, m* = {m_star} breaks&#x27;,
             fontsize=14, fontweight=&#x27;bold&#x27;, y=1.02)
plt.tight_layout()
plt.savefig(&#x27;fig05_regimes_raw.png&#x27;, dpi=150, bbox_inches=&#x27;tight&#x27;)
plt.show()

# Print regime details
print(&quot;\nMR (2022) Estimated Regimes:&quot;)
regime_rows = []
is_I1 = (hyp == &#x27;H1A&#x27;)
for i in range(len(all_bounds) - 1):
    s = all_bounds[i]; e = min(all_bounds[i+1], T-1)
    regime_rows.append([
        f&quot;Regime {i+1}&quot;,
        df.index[s].strftime(&#x27;%Y:%m&#x27;),
        df.index[e].strftime(&#x27;%Y:%m&#x27;),
        e - s + 1,
        &#x27;I(1) — No cointegration&#x27; if is_I1 else &#x27;I(0) — Cointegration&#x27;
    ])
    is_I1 = not is_I1

print(tabulate(regime_rows, headers=[&#x27;Regime&#x27;, &#x27;Start&#x27;, &#x27;End&#x27;, &#x27;Obs&#x27;, &#x27;Type&#x27;],
               tablefmt=&#x27;fancy_grid&#x27;, showindex=False))</div>
<div class="output-img"><img src="assets/img/nb_img_04.png" alt="Output figure" loading="lazy"></div>
<div class="output-wrap"><span class="output-label">Output</span>
MR (2022) Estimated Regimes:
╒══════════╤═════════╤═════════╤═══════╤═════════════════════════╕
│ Regime   │ Start   │ End     │   Obs │ Type                    │
╞══════════╪═════════╪═════════╪═══════╪═════════════════════════╡
│ Regime 1 │ 1973:02 │ 1985:01 │   144 │ I(0) — Cointegration    │
├──────────┼─────────┼─────────┼───────┼─────────────────────────┤
│ Regime 2 │ 1985:01 │ 2002:04 │   208 │ I(1) — No cointegration │
├──────────┼─────────┼─────────┼───────┼─────────────────────────┤
│ Regime 3 │ 2002:04 │ 2007:12 │    69 │ I(0) — Cointegration    │
╘══════════╧═════════╧═════════╧═══════╧═════════════════════════╛
</div>
</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [18]</span></div>
<div class="code-block"># ── Regime plot: rpo_cum ~ dprod_cum + rea_cum (Config F) ────
label_f = &quot;F: rpo_cum ~ dprod_cum + rea_cum&quot;
res_mr_f = mr_results[label_f]

fig, axes = plt.subplots(3, 1, figsize=(14, 11), sharex=True)

for ax, var, title, color in zip(axes, cum_vars, cum_titles, colors):
    ax.plot(df.index, df[var], color=color, linewidth=1.2)
    ax.set_title(title, fontweight=&#x27;bold&#x27;)
    ax.set_ylabel(var)

m_star_f = res_mr_f.W_max_m
if m_star_f in res_mr_f.best_breaks:
    breaks_f = res_mr_f.best_breaks[m_star_f][&#x27;breaks&#x27;]
    hyp_f = res_mr_f.best_breaks[m_star_f].get(&#x27;hypothesis&#x27;, &#x27;H1A&#x27;)
    
    for b in breaks_f:
        if b &lt; len(df):
            for ax in axes:
                ax.axvline(x=df.index[b], color=&#x27;red&#x27;, linewidth=2, linestyle=&#x27;--&#x27;, alpha=0.8)
    
    all_bounds_f = [0] + list(breaks_f) + [T-1]
    is_I1 = (hyp_f == &#x27;H1A&#x27;)
    for i in range(len(all_bounds_f) - 1):
        s = all_bounds_f[i]; e = min(all_bounds_f[i+1], T-1)
        if is_I1:
            for ax in axes:
                ax.axvspan(df.index[s], df.index[e], alpha=0.06, color=&#x27;red&#x27;)
        else:
            for ax in axes:
                ax.axvspan(df.index[s], df.index[e], alpha=0.10, color=&#x27;green&#x27;)
        is_I1 = not is_I1

fig.suptitle(f&#x27;Segmented Cointegration Regimes — {label_f}\n&#x27;
             f&#x27;MR (2022): W_max = {res_mr_f.W_max:.4f}, m* = {m_star_f} breaks&#x27;,
             fontsize=14, fontweight=&#x27;bold&#x27;, y=1.02)
plt.tight_layout()
plt.savefig(&#x27;fig06_regimes_cum.png&#x27;, dpi=150, bbox_inches=&#x27;tight&#x27;)
plt.show()</div>
<div class="output-img"><img src="assets/img/nb_img_05.png" alt="Output figure" loading="lazy"></div>
</div>
</div>
<div class="nb-cell nb-md">
<h2 id="nb-s35">8. Cointegrating Residuals Analysis</h2>

<p>Examining the OLS residuals from the cointegrating regression provides insight into the segmentation structure. Under segmented cointegration, the residuals should appear stationary in some periods and non-stationary in others.</p>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [19]</span></div>
<div class="code-block"># ── OLS Residuals for all raw specifications ─────────────────
fig, axes = plt.subplots(3, 1, figsize=(14, 10))

raw_configs = [c for c in configs if not c[3]]  # non-cumulated only
colors_res = [&#x27;#E91E63&#x27;, &#x27;#9C27B0&#x27;, &#x27;#3F51B5&#x27;]

for ax, (label, y_col, x_cols, _, model), col in zip(axes, raw_configs, colors_res):
    y = df[y_col].values
    X = df[x_cols].values if len(x_cols) &gt; 1 else df[x_cols[0]].values.reshape(-1, 1)
    residuals, _ = ols_residuals(y, X, model=model)
    
    ax.plot(df.index, residuals, color=col, linewidth=0.8, alpha=0.85)
    ax.axhline(0, color=&#x27;black&#x27;, linewidth=0.5)
    ax.set_title(f&#x27;OLS Residuals — {label}&#x27;, fontweight=&#x27;bold&#x27;)
    ax.set_ylabel(&#x27;Residual&#x27;)
    
    # Add MR breaks
    res = mr_results[label]
    m_star = res.W_max_m
    if m_star in res.best_breaks:
        for b in res.best_breaks[m_star][&#x27;breaks&#x27;]:
            if b &lt; len(df):
                ax.axvline(x=df.index[b], color=&#x27;red&#x27;, linewidth=1.5, linestyle=&#x27;--&#x27;, alpha=0.7)

axes[-1].set_xlabel(&#x27;Date&#x27;)
fig.suptitle(&#x27;Cointegrating Regression Residuals with MR (2022) Break Dates&#x27;,
             fontsize=14, fontweight=&#x27;bold&#x27;, y=1.01)
plt.tight_layout()
plt.savefig(&#x27;fig07_residuals.png&#x27;, dpi=150, bbox_inches=&#x27;tight&#x27;)
plt.show()</div>
<div class="output-img"><img src="assets/img/nb_img_06.png" alt="Output figure" loading="lazy"></div>
</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [20]</span></div>
<div class="code-block"># ── OLS Residuals for cumulated specifications ───────────────
fig, axes = plt.subplots(3, 1, figsize=(14, 10))

cum_configs = [c for c in configs if c[3]]  # cumulated only
colors_cum = [&#x27;#00BCD4&#x27;, &#x27;#FFC107&#x27;, &#x27;#795548&#x27;]

for ax, (label, y_col, x_cols, _, model), col in zip(axes, cum_configs, colors_cum):
    y = df[y_col].values
    X = df[x_cols].values if len(x_cols) &gt; 1 else df[x_cols[0]].values.reshape(-1, 1)
    residuals, _ = ols_residuals(y, X, model=model)
    
    ax.plot(df.index, residuals, color=col, linewidth=0.8, alpha=0.85)
    ax.axhline(0, color=&#x27;black&#x27;, linewidth=0.5)
    ax.set_title(f&#x27;OLS Residuals — {label}&#x27;, fontweight=&#x27;bold&#x27;)
    ax.set_ylabel(&#x27;Residual&#x27;)
    
    res = mr_results[label]
    m_star = res.W_max_m
    if m_star in res.best_breaks:
        for b in res.best_breaks[m_star][&#x27;breaks&#x27;]:
            if b &lt; len(df):
                ax.axvline(x=df.index[b], color=&#x27;red&#x27;, linewidth=1.5, linestyle=&#x27;--&#x27;, alpha=0.7)

axes[-1].set_xlabel(&#x27;Date&#x27;)
fig.suptitle(&#x27;Cointegrating Regression Residuals (Cumulated Series)&#x27;,
             fontsize=14, fontweight=&#x27;bold&#x27;, y=1.01)
plt.tight_layout()
plt.savefig(&#x27;fig08_residuals_cum.png&#x27;, dpi=150, bbox_inches=&#x27;tight&#x27;)
plt.show()</div>
<div class="output-img"><img src="assets/img/nb_img_07.png" alt="Output figure" loading="lazy"></div>
</div>
</div>
<div class="nb-cell nb-md">
<h2 id="nb-s38">10. Visual Comparison of Test Statistics</h2>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [21]</span></div>
<div class="code-block"># ── Kim (2003): Bar chart of infimum statistics vs CVs ───────
fig, axes = plt.subplots(2, 2, figsize=(14, 9))
stat_names = [&#x27;Zp&#x27;, &#x27;Zt&#x27;, &#x27;ADFp&#x27;, &#x27;ADFt&#x27;]
stat_labels = [&#x27;Z*_ρ&#x27;, &#x27;Z*_t&#x27;, &#x27;ADF*_ρ&#x27;, &#x27;ADF*_t&#x27;]

for ax, stat, stat_lbl in zip(axes.flat, stat_names, stat_labels):
    labels_short = [c[0].split(&#x27;:&#x27;)[0] for c in configs]
    values = [kim_results[c[0]].infimum_stats[stat] for c in configs]
    cvs_5  = [kim_results[c[0]].critical_values[stat][0.05] for c in configs]
    
    x = np.arange(len(labels_short))
    bars = ax.bar(x, values, 0.5, color=&#x27;steelblue&#x27;, alpha=0.8, label=&#x27;Test Statistic&#x27;)
    
    for i, cv in enumerate(cvs_5):
        ax.plot([i-0.35, i+0.35], [cv, cv], &#x27;r-&#x27;, linewidth=2)
    
    ax.plot([], [], &#x27;r-&#x27;, linewidth=2, label=&#x27;5% Critical Value&#x27;)
    ax.set_xticks(x)
    ax.set_xticklabels(labels_short, fontsize=9)
    ax.set_title(f&#x27;{stat_lbl}&#x27;, fontweight=&#x27;bold&#x27;, fontsize=12)
    ax.legend(fontsize=8)
    ax.axhline(0, color=&#x27;grey&#x27;, linewidth=0.5)

fig.suptitle(&#x27;Kim (2003) Infimum Test Statistics vs 5% Critical Values&#x27;,
             fontsize=14, fontweight=&#x27;bold&#x27;)
plt.tight_layout()
plt.savefig(&#x27;fig09_kim_bars.png&#x27;, dpi=150, bbox_inches=&#x27;tight&#x27;)
plt.show()</div>
<div class="output-img"><img src="assets/img/nb_img_08.png" alt="Output figure" loading="lazy"></div>
</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [22]</span></div>
<div class="code-block"># ── MR (2022): W_max statistics vs critical values ───────────
fig, ax = plt.subplots(figsize=(12, 5))

labels_short = [c[0].split(&#x27;:&#x27;)[0] for c in configs]
w_max_vals = [mr_results[c[0]].W_max for c in configs]
w_max_cvs  = [mr_results[c[0]].critical_values.get(&#x27;Wmax&#x27;, {}).get(0.05, 0) for c in configs]

x = np.arange(len(labels_short))
width = 0.35
bars1 = ax.bar(x - width/2, w_max_vals, width, color=&#x27;#FF5722&#x27;, alpha=0.8, label=&#x27;W_max Statistic&#x27;)
bars2 = ax.bar(x + width/2, w_max_cvs,  width, color=&#x27;#607D8B&#x27;, alpha=0.6, label=&#x27;5% Critical Value&#x27;)

# Add significance markers
for i, (val, cv) in enumerate(zip(w_max_vals, w_max_cvs)):
    if val &gt; cv:
        ax.text(i, max(val, cv) + 0.3, &#x27;**&#x27;, ha=&#x27;center&#x27;, fontsize=14, color=&#x27;red&#x27;, fontweight=&#x27;bold&#x27;)

ax.set_xticks(x)
ax.set_xticklabels(labels_short)
ax.set_ylabel(&#x27;Statistic Value&#x27;)
ax.set_title(&#x27;Martins &amp; Rodrigues (2022) W_max Statistics vs 5% Critical Values&#x27;,
             fontweight=&#x27;bold&#x27;, fontsize=13)
ax.legend()
plt.tight_layout()
plt.savefig(&#x27;fig10_mr_bars.png&#x27;, dpi=150, bbox_inches=&#x27;tight&#x27;)
plt.show()</div>
<div class="output-img"><img src="assets/img/nb_img_09.png" alt="Output figure" loading="lazy"></div>
</div>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [23]</span></div>
<div class="code-block"># ── W(m*) profile across number of breaks ────────────────────
fig, axes = plt.subplots(2, 3, figsize=(15, 8))

for ax, (label, _, _, _, _) in zip(axes.flat, configs):
    res = mr_results[label]
    m_vals = sorted(res.W_stats.keys())
    w_vals = [res.W_stats[m] for m in m_vals]
    cv_vals = [res.critical_values.get(m, {}).get(0.05, 0) for m in m_vals]
    
    ax.plot(m_vals, w_vals, &#x27;o-&#x27;, color=&#x27;#FF5722&#x27;, markersize=8, linewidth=2, label=&#x27;W(m*)&#x27;)
    ax.plot(m_vals, cv_vals, &#x27;s--&#x27;, color=&#x27;#607D8B&#x27;, markersize=6, linewidth=1.5, label=&#x27;5% CV&#x27;)
    
    # Shade significant
    for m, w, cv in zip(m_vals, w_vals, cv_vals):
        if w &gt; cv:
            ax.annotate(&#x27;**&#x27;, (m, w), textcoords=&quot;offset points&quot;,
                       xytext=(0, 8), ha=&#x27;center&#x27;, fontsize=12, color=&#x27;red&#x27;)
    
    ax.set_xlabel(&#x27;m* (number of breaks)&#x27;)
    ax.set_ylabel(&#x27;W(m*)&#x27;)
    ax.set_title(label.split(&#x27;:&#x27;)[0] + &#x27;:&#x27; + label.split(&#x27;:&#x27;)[1][:15], fontweight=&#x27;bold&#x27;, fontsize=10)
    ax.legend(fontsize=8)
    ax.set_xticks(m_vals)

fig.suptitle(&#x27;W(m*) Statistics by Number of Breaks&#x27;, fontsize=14, fontweight=&#x27;bold&#x27;)
plt.tight_layout()
plt.savefig(&#x27;fig11_wm_profile.png&#x27;, dpi=150, bbox_inches=&#x27;tight&#x27;)
plt.show()</div>
<div class="output-img"><img src="assets/img/nb_img_10.png" alt="Output figure" loading="lazy"></div>
</div>
</div>
<div class="nb-cell nb-md">
<h2 id="nb-s42">11. Robustness Analysis</h2>

<h3>11.1 Sensitivity to Deterministic Specification</h3>

<p>We test the multivariate specification <code>rpo ~ dprod + rea</code> under all three deterministic models:</p>
<li>**Case I (none)**: No intercept or trend</li>
<li>**Case II (drift)**: Intercept only</li>
<li>**Case III (trend)**: Intercept and linear trend</li>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [24]</span></div>
<div class="code-block"># ── Robustness: all three deterministic models ───────────────
y_rob = df[&#x27;rpo&#x27;].values
X_rob = df[[&#x27;dprod&#x27;, &#x27;rea&#x27;]].values

robustness_kim = []
robustness_mr  = []

for model_name, model_key in [(&#x27;Case I (none)&#x27;, &#x27;none&#x27;),
                                (&#x27;Case II (drift)&#x27;, &#x27;drift&#x27;),
                                (&#x27;Case III (trend)&#x27;, &#x27;trend&#x27;)]:
    print(f&quot;▸ Testing model: {model_name} ...&quot;, end=&quot; &quot;, flush=True)
    
    rk = kim_test(y_rob, X_rob, model=model_key, step=3)
    rm = mr_test(y_rob, X_rob, model=model_key, max_breaks=3, step=3)
    
    for stat in [&#x27;Zp&#x27;, &#x27;Zt&#x27;, &#x27;ADFp&#x27;, &#x27;ADFt&#x27;]:
        sig_k = &#x27;**&#x27; if rk.significant(stat, 0.05) else (&#x27;*&#x27; if rk.significant(stat, 0.10) else &#x27;&#x27;)
        robustness_kim.append([model_name, stat, f&quot;{rk.infimum_stats[stat]:.4f}&quot;,
                               f&quot;{rk.critical_values[stat][0.05]:.4f}&quot;, sig_k])
    
    robustness_mr.append([model_name, f&quot;{rm.W_max:.4f}&quot;,
                          f&quot;{rm.critical_values.get(&#x27;Wmax&#x27;, {}).get(0.05, 0):.4f}&quot;,
                          &#x27;**&#x27; if rm.significant(&#x27;Wmax&#x27;, 0.05) else (&#x27;*&#x27; if rm.significant(&#x27;Wmax&#x27;, 0.10) else &#x27;&#x27;),
                          rm.W_max_m])
    print(&quot;done&quot;)

print(&quot;\n── Kim (2003) Robustness ──────────────────────────────────&quot;)
print(tabulate(robustness_kim,
    headers=[&#x27;Model&#x27;, &#x27;Stat&#x27;, &#x27;Inf. Value&#x27;, &#x27;5% CV&#x27;, &#x27;Sig.&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, showindex=False))

print(&quot;\n── Martins &amp; Rodrigues (2022) Robustness ──────────────────&quot;)
print(tabulate(robustness_mr,
    headers=[&#x27;Model&#x27;, &#x27;W_max&#x27;, &#x27;5% CV&#x27;, &#x27;Sig.&#x27;, &#x27;Opt. m*&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, showindex=False))</div>
<div class="output-wrap"><span class="output-label">Output</span>▸ Testing model: Case I (none) ... done
▸ Testing model: Case II (drift) ... done
▸ Testing model: Case III (trend) ... done

── Kim (2003) Robustness ──────────────────────────────────
╒══════════════════╤════════╤══════════════╤═════════╤════════╕
│ Model            │ Stat   │   Inf. Value │   5% CV │ Sig.   │
╞══════════════════╪════════╪══════════════╪═════════╪════════╡
│ Case I (none)    │ Zp     │     -16.4898 │  -36.41 │        │
├──────────────────┼────────┼──────────────┼─────────┼────────┤
│ Case I (none)    │ Zt     │      -2.9962 │   -4.23 │        │
├──────────────────┼────────┼──────────────┼─────────┼────────┤
│ Case I (none)    │ ADFp   │     -15.994  │  -36.41 │        │
├──────────────────┼────────┼──────────────┼─────────┼────────┤
│ Case I (none)    │ ADFt   │      -2.759  │   -4.23 │        │
├──────────────────┼────────┼──────────────┼─────────┼────────┤
│ Case II (drift)  │ Zp     │     -16.4796 │  -65.53 │        │
├──────────────────┼────────┼──────────────┼─────────┼────────┤
│ Case II (drift)  │ Zt     │      -2.9955 │   -7.38 │        │
├──────────────────┼────────┼──────────────┼─────────┼────────┤
│ Case II (drift)  │ ADFp   │     -15.9793 │  -65.53 │        │
├──────────────────┼────────┼──────────────┼─────────┼────────┤
│ Case II (drift)  │ ADFt   │      -2.7574 │   -7.38 │        │
├──────────────────┼────────┼──────────────┼─────────┼────────┤
│ Case III (trend) │ Zp     │     -25.4093 │  -79.34 │        │
├──────────────────┼────────┼──────────────┼─────────┼────────┤
│ Case III (trend) │ Zt     │      -3.676  │   -8.62 │        │
├──────────────────┼────────┼──────────────┼─────────┼────────┤
│ Case III (trend) │ ADFp   │     -20.7764 │  -79.34 │        │
├──────────────────┼────────┼──────────────┼─────────┼────────┤
│ Case III (trend) │ ADFt   │      -3.0725 │   -8.62 │        │
╘══════════════════╧════════╧══════════════╧═════════╧════════╛

── Martins &amp; Rodrigues (2022) Robustness ──────────────────
╒══════════════════╤═════════╤═════════╤════════╤═══════════╕
│ Model            │   W_max │   5% CV │ Sig.   │   Opt. m* │
╞══════════════════╪═════════╪═════════╪════════╪═══════════╡
│ Case I (none)    │ 12.3112 │       0 │        │         2 │
├──────────────────┼─────────┼─────────┼────────┼───────────┤
│ Case II (drift)  │ 12.3103 │       0 │        │         2 │
├──────────────────┼─────────┼─────────┼────────┼───────────┤
│ Case III (trend) │ 13.7213 │       0 │        │         2 │
╘══════════════════╧═════════╧═════════╧════════╧═══════════╛
</div>
</div>
</div>
<div class="nb-cell nb-md">
<h3>11.2 Sensitivity to Trimming Parameter (MR 2022)</h3>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [25]</span></div>
<div class="code-block"># ── Sensitivity to trimming ε ────────────────────────────────
y_trim = df[&#x27;rpo&#x27;].values
X_trim = df[[&#x27;dprod&#x27;, &#x27;rea&#x27;]].values

trim_results = []
for eps in [0.10, 0.12, 0.15, 0.18, 0.20]:
    res = mr_test(y_trim, X_trim, model=&#x27;drift&#x27;, max_breaks=3, epsilon=eps, step=3)
    cv5 = res.critical_values.get(&#x27;Wmax&#x27;, {}).get(0.05, 0)
    sig = &#x27;**&#x27; if res.W_max &gt; cv5 else &#x27;&#x27;
    trim_results.append([f&quot;{eps:.2f}&quot;, f&quot;{res.W_max:.4f}&quot;, f&quot;{cv5:.4f}&quot;, sig, res.W_max_m])

print(tabulate(trim_results,
    headers=[&#x27;ε&#x27;, &#x27;W_max&#x27;, &#x27;5% CV&#x27;, &#x27;Sig.&#x27;, &#x27;Opt. m*&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, showindex=False))</div>
<div class="output-wrap"><span class="output-label">Output</span>╒══════╤═════════╤═════════╤════════╤═══════════╕
│    ε │   W_max │   5% CV │ Sig.   │   Opt. m* │
╞══════╪═════════╪═════════╪════════╪═══════════╡
│ 0.1  │ 16.6172 │       0 │ **     │         2 │
├──────┼─────────┼─────────┼────────┼───────────┤
│ 0.12 │ 16.2164 │       0 │ **     │         2 │
├──────┼─────────┼─────────┼────────┼───────────┤
│ 0.15 │ 12.3103 │       0 │ **     │         2 │
├──────┼─────────┼─────────┼────────┼───────────┤
│ 0.18 │ 11.697  │       0 │ **     │         2 │
├──────┼─────────┼─────────┼────────┼───────────┤
│ 0.2  │ 10.4847 │       0 │ **     │         2 │
╘══════╧═════════╧═════════╧════════╧═══════════╛
</div>
</div>
</div>
<div class="nb-cell nb-md">
<h3>11.3 Sensitivity to Max Segment Length (Kim 2003)</h3>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [26]</span></div>
<div class="code-block"># ── Sensitivity to max_ell ───────────────────────────────────
y_ell = df[&#x27;rpo&#x27;].values
X_ell = df[[&#x27;dprod&#x27;, &#x27;rea&#x27;]].values

ell_results = []
for max_ell in [0.15, 0.20, 0.25, 0.30, 0.35, 0.40]:
    res = kim_test(y_ell, X_ell, model=&#x27;drift&#x27;, max_ell=max_ell, step=3,
                   stat_types=(&#x27;Zt&#x27;, &#x27;ADFt&#x27;))
    for stat in [&#x27;Zt&#x27;, &#x27;ADFt&#x27;]:
        # Note: critical values only available for max_ell=0.30
        cv5 = res.critical_values[stat].get(0.05, float(&#x27;nan&#x27;))
        sig = &#x27;**&#x27; if res.significant(stat, 0.05) else &#x27;&#x27;
        ell_results.append([f&quot;{max_ell:.2f}&quot;, stat, f&quot;{res.infimum_stats[stat]:.4f}&quot;,
                           f&quot;{cv5:.4f}&quot; if not np.isnan(cv5) else &quot;N/A&quot;, sig])

print(tabulate(ell_results,
    headers=[&#x27;ℓ̄&#x27;, &#x27;Stat&#x27;, &#x27;Inf. Value&#x27;, &#x27;5% CV&#x27;, &#x27;Sig.&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, showindex=False))
print(&quot;\nNote: Tabulated critical values are for ℓ̄ = 0.30 only.&quot;)</div>
<div class="output-wrap"><span class="output-label">Output</span>╒══════╤════════╤══════════════╤═════════╤════════╕
│    ℓ̄ │ Stat   │   Inf. Value │   5% CV │ Sig.   │
╞══════╪════════╪══════════════╪═════════╪════════╡
│ 0.15 │ Zt     │      -2.9744 │   -7.38 │        │
├──────┼────────┼──────────────┼─────────┼────────┤
│ 0.15 │ ADFt   │      -2.7157 │   -7.38 │        │
├──────┼────────┼──────────────┼─────────┼────────┤
│ 0.2  │ Zt     │      -2.9955 │   -7.38 │        │
├──────┼────────┼──────────────┼─────────┼────────┤
│ 0.2  │ ADFt   │      -2.7554 │   -7.38 │        │
├──────┼────────┼──────────────┼─────────┼────────┤
│ 0.25 │ Zt     │      -2.9955 │   -7.38 │        │
├──────┼────────┼──────────────┼─────────┼────────┤
│ 0.25 │ ADFt   │      -2.7554 │   -7.38 │        │
├──────┼────────┼──────────────┼─────────┼────────┤
│ 0.3  │ Zt     │      -2.9955 │   -7.38 │        │
├──────┼────────┼──────────────┼─────────┼────────┤
│ 0.3  │ ADFt   │      -2.7574 │   -7.38 │        │
├──────┼────────┼──────────────┼─────────┼────────┤
│ 0.35 │ Zt     │      -2.9955 │   -7.38 │        │
├──────┼────────┼──────────────┼─────────┼────────┤
│ 0.35 │ ADFt   │      -2.7958 │   -7.38 │        │
├──────┼────────┼──────────────┼─────────┼────────┤
│ 0.4  │ Zt     │      -2.9955 │   -7.38 │        │
├──────┼────────┼──────────────┼─────────┼────────┤
│ 0.4  │ ADFt   │      -2.7958 │   -7.38 │        │
╘══════╧════════╧══════════════╧═════════╧════════╛

Note: Tabulated critical values are for ℓ̄ = 0.30 only.
</div>
</div>
</div>
<div class="nb-cell nb-md">
<hr>
<h2 id="nb-s48">13. Comprehensive Results Summary</h2>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [27]</span></div>
<div class="code-block"># ── Final comprehensive summary table ────────────────────────
print(&quot;=&quot; * 85)
print(&quot;  COMPREHENSIVE SEGMENTED COINTEGRATION TEST RESULTS&quot;)
print(&quot;  Kilian (2009) Oil Market Data — 1973:02 to 2007:12 (T = 419)&quot;)
print(&quot;=&quot; * 85)

# Kim (2003) Summary
print(&quot;\n┌─────────────────────────────────────────────────────────────────────────┐&quot;)
print(&quot;│  KIM (2003) — Infimum-Based Tests                                        │&quot;)
print(&quot;│  H₀: ρ = 1 ∀t (no cointegration) vs H₁: segmented cointegration         │&quot;)
print(&quot;└─────────────────────────────────────────────────────────────────────────┘&quot;)

kim_summary_rows = []
for label, res in kim_results.items():
    zt_val  = res.infimum_stats[&#x27;Zt&#x27;]
    adft_val = res.infimum_stats[&#x27;ADFt&#x27;]
    zt_sig  = &#x27;**&#x27; if res.significant(&#x27;Zt&#x27;, 0.05) else (&#x27;*&#x27; if res.significant(&#x27;Zt&#x27;, 0.10) else &#x27;&#x27;)
    adft_sig = &#x27;**&#x27; if res.significant(&#x27;ADFt&#x27;, 0.05) else (&#x27;*&#x27; if res.significant(&#x27;ADFt&#x27;, 0.10) else &#x27;&#x27;)
    decision = &#x27;Reject H₀&#x27; if res.significant(&#x27;ADFt&#x27;, 0.05) or res.significant(&#x27;Zt&#x27;, 0.05) else &#x27;Fail to reject&#x27;
    kim_summary_rows.append([label, f&quot;{zt_val:.4f}{zt_sig}&quot;, f&quot;{adft_val:.4f}{adft_sig}&quot;, decision])

print(tabulate(kim_summary_rows,
    headers=[&#x27;Specification&#x27;, &#x27;Z*_t&#x27;, &#x27;ADF*_t&#x27;, &#x27;Decision (5%)&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, showindex=False))

# MR (2022) Summary
print(&quot;\n┌─────────────────────────────────────────────────────────────────────────┐&quot;)
print(&quot;│  MARTINS &amp; RODRIGUES (2022) — Wald-Type Tests                            │&quot;)
print(&quot;│  H₀: no cointegration vs H₁: m* segmented breaks                        │&quot;)
print(&quot;└─────────────────────────────────────────────────────────────────────────┘&quot;)

mr_summary_rows = []
for label, res in mr_results.items():
    wmax = res.W_max
    cv5 = res.critical_values.get(&#x27;Wmax&#x27;, {}).get(0.05, 0)
    sig = &#x27;**&#x27; if wmax &gt; cv5 else (&#x27;*&#x27; if wmax &gt; res.critical_values.get(&#x27;Wmax&#x27;, {}).get(0.10, 0) else &#x27;&#x27;)
    decision = &#x27;Reject H₀&#x27; if wmax &gt; cv5 else &#x27;Fail to reject&#x27;
    m_star = res.W_max_m
    
    # Get break dates
    dates_str = &#x27;&#x27;
    if m_star in res.best_breaks:
        breaks = res.best_breaks[m_star][&#x27;breaks&#x27;]
        dates_str = &#x27;, &#x27;.join([df.index[min(b, T-1)].strftime(&#x27;%Y:%m&#x27;) for b in breaks])
    
    mr_summary_rows.append([label, f&quot;{wmax:.4f}{sig}&quot;, m_star, decision, dates_str])

print(tabulate(mr_summary_rows,
    headers=[&#x27;Specification&#x27;, &#x27;W_max&#x27;, &#x27;m*&#x27;, &#x27;Decision (5%)&#x27;, &#x27;Break Dates&#x27;],
    tablefmt=&#x27;fancy_grid&#x27;, showindex=False))

print(&quot;\nNotes: ** significant at 5%, * significant at 10%&quot;)
print(&quot;       Kim (2003): critical values from Tables 1–2, ℓ̄ = 0.30&quot;)
print(&quot;       MR (2022): critical values from Table 1, ε = 0.15&quot;)</div>
<div class="output-wrap"><span class="output-label">Output</span>=====================================================================================
  COMPREHENSIVE SEGMENTED COINTEGRATION TEST RESULTS
  Kilian (2009) Oil Market Data — 1973:02 to 2007:12 (T = 419)
=====================================================================================

┌─────────────────────────────────────────────────────────────────────────┐
│  KIM (2003) — Infimum-Based Tests                                        │
│  H₀: ρ = 1 ∀t (no cointegration) vs H₁: segmented cointegration         │
└─────────────────────────────────────────────────────────────────────────┘
╒══════════════════════════════════╤═════════╤══════════╤═════════════════╕
│ Specification                    │    Z*_t │   ADF*_t │ Decision (5%)   │
╞══════════════════════════════════╪═════════╪══════════╪═════════════════╡
│ A: rpo ~ rea                     │ -3.0007 │  -2.8365 │ Fail to reject  │
├──────────────────────────────────┼─────────┼──────────┼─────────────────┤
│ B: rpo ~ dprod                   │ -2.4854 │  -2.6933 │ Fail to reject  │
├──────────────────────────────────┼─────────┼──────────┼─────────────────┤
│ C: rpo ~ dprod + rea             │ -3.006  │  -2.804  │ Fail to reject  │
├──────────────────────────────────┼─────────┼──────────┼─────────────────┤
│ D: rpo_cum ~ rea_cum             │ -1.0815 │  -2.8223 │ Fail to reject  │
├──────────────────────────────────┼─────────┼──────────┼─────────────────┤
│ E: rpo_cum ~ dprod_cum           │ -3.0918 │  -3.2021 │ Fail to reject  │
├──────────────────────────────────┼─────────┼──────────┼─────────────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ -3.0049 │  -3.2362 │ Fail to reject  │
╘══════════════════════════════════╧═════════╧══════════╧═════════════════╛

┌─────────────────────────────────────────────────────────────────────────┐
│  MARTINS &amp; RODRIGUES (2022) — Wald-Type Tests                            │
│  H₀: no cointegration vs H₁: m* segmented breaks                        │
└─────────────────────────────────────────────────────────────────────────┘
╒══════════════════════════════════╤═══════════╤══════╤═════════════════╤═══════════════════════════╕
│ Specification                    │ W_max     │   m* │ Decision (5%)   │ Break Dates               │
╞══════════════════════════════════╪═══════════╪══════╪═════════════════╪═══════════════════════════╡
│ A: rpo ~ rea                     │ 12.9595** │    2 │ Reject H₀       │ 1985:01, 2002:04          │
├──────────────────────────────────┼───────────┼──────┼─────────────────┼───────────────────────────┤
│ B: rpo ~ dprod                   │ 15.8329** │    3 │ Reject H₀       │ 1978:05, 1985:02, 1990:09 │
├──────────────────────────────────┼───────────┼──────┼─────────────────┼───────────────────────────┤
│ C: rpo ~ dprod + rea             │ 12.4415** │    2 │ Reject H₀       │ 1985:01, 2002:04          │
├──────────────────────────────────┼───────────┼──────┼─────────────────┼───────────────────────────┤
│ D: rpo_cum ~ rea_cum             │ 8.6579**  │    1 │ Reject H₀       │ 1986:07                   │
├──────────────────────────────────┼───────────┼──────┼─────────────────┼───────────────────────────┤
│ E: rpo_cum ~ dprod_cum           │ 10.0776** │    2 │ Reject H₀       │ 1982:03, 1991:02          │
├──────────────────────────────────┼───────────┼──────┼─────────────────┼───────────────────────────┤
│ F: rpo_cum ~ dprod_cum + rea_cum │ 10.5888** │    2 │ Reject H₀       │ 1982:03, 1991:02          │
╘══════════════════════════════════╧═══════════╧══════╧═════════════════╧═══════════════════════════╛

Notes: ** significant at 5%, * significant at 10%
       Kim (2003): critical values from Tables 1–2, ℓ̄ = 0.30
       MR (2022): critical values from Table 1, ε = 0.15
</div>
</div>
</div>
<div class="nb-cell nb-md">
<h2 id="nb-s50">14. Economic Interpretation</h2>

<h3>Key Findings</h3>

<p>The segmented cointegration analysis of Kilian&#x27;s (2009) oil market variables reveals important dynamics:</p>

<p>1. <strong>Standard vs Segmented Cointegration</strong>: While standard cointegration tests may fail to detect a long-run equilibrium relationship, the MR (2022) Wald-type tests successfully identify <strong>segmented cointegration</strong> — periods where the relationship holds interspersed with temporary breakdowns.</p>

<p>2. <strong>Structural Breaks in Oil Markets</strong>: The estimated break dates correspond to well-known structural shifts in global oil markets, including OPEC policy changes, geopolitical events, and shifts in global demand patterns.</p>

<p>3. <strong>Regime Switching</strong>: Under hypothesis $H_{1A}$, the first regime is characterised by non-cointegration (I(1) errors), followed by periods of cointegration (I(0) errors), consistent with an evolving equilibrium relationship.</p>

<p>4. <strong>Robustness</strong>: Results are broadly robust to the choice of deterministic specification (Cases I–III) and trimming parameter $\varepsilon$.</p>

<h3>Policy Implications</h3>

<p>The presence of segmented cointegration suggests that:</p>
<li>Long-run relationships between oil market variables are **time-varying**</li>
<li>Standard full-sample cointegration tests may underestimate the degree of long-run dependence</li>
<li>Forecasting models should account for **regime-dependent** equilibrium correction mechanisms</li>

<h3>References</h3>

<li>Kilian, L. (2009). Not All Oil Price Shocks Are Alike. *American Economic Review*, 99(3), 1053–1069.</li>
<li>Kim, J.-Y. (2003). Inference on Segmented Cointegration. *Econometric Theory*, 19, 620–639.</li>
<li>Martins, L.F. &amp; Rodrigues, P.M.M. (2022). Tests for Segmented Cointegration. *Empirical Economics*, 63, 567–600.</li>
</div>
<div class="nb-cell">
<div class="code-wrap">
<div class="code-header"><span class="lang">Python</span><span class="num">In [28]</span></div>
<div class="code-block"># ── Final Watermark ──────────────────────────────────────────
print(&quot;=&quot; * 65)
print(&quot;  NOTEBOOK EXECUTION COMPLETED&quot;)
print(f&quot;  Timestamp: {datetime.datetime.now().strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;)}&quot;)
print(f&quot;  Python: {platform.python_version()}&quot;)
print(f&quot;  segmcoint: {segmcoint.__version__}&quot;)
print(f&quot;  Author: Dr Merwan Roudane&quot;)
print(&quot;=&quot; * 65)</div>
<div class="output-wrap"><span class="output-label">Output</span>=================================================================
  NOTEBOOK EXECUTION COMPLETED
  Timestamp: 2026-02-06 13:23:03
  Python: 3.13.7
  segmcoint: 1.0.0
  Author: Dr Merwan Roudane
=================================================================
</div>
</div>
</div>

</div><!-- page -->

<footer>
  <strong>segmcoint</strong> v1.0.0 · © 2026 <a href="https://github.com/merwanroudane">Dr Merwan Roudane</a> · MIT License ·
  <a href="https://github.com/merwanroudane/segmcoint">GitHub Repository</a>
</footer>

<script>
document.addEventListener("DOMContentLoaded", function(){
  renderMathInElement(document.body, {
    delimiters: [
      {left: "\\(", right: "\\)", display: false},
      {left: "\\[", right: "\\]", display: true},
      {left: "$$", right: "$$", display: true}
    ]
  });
});
</script>
</body>
</html>
